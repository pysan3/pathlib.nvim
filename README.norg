@document.meta
title: README
description:
authors: takuto
categories:
created: 2023-11-14
updated: 2024-02-16T11:36:41+0900
version: 1.1.1
@end

@embed html
<div align="center">
  <h1>üêç pathlib.nvim</h1>
  <p>
    <strong>
      OS independent, ultimate solution to path handling in neovim.
    </strong>
  </p>
</div>
@end

  ‚ùó *This is still very WIP. Will be available in February at the earliest.*

  {https://neovim.io/}[!{https://img.shields.io/badge/NeoVim-%2357A143.svg?&style=for-the-badge&logo=neovim&logoColor=white}[Neovim]]
  {https://www.lua.org/}[!{https://img.shields.io/badge/lua-%232C2D72.svg?style=for-the-badge&logo=lua&logoColor=white}[Lua]]

  {https://github.com/pysan3/pathlib.nvim/blob/master/LICENSE}[!{https://img.shields.io/github/license/pysan3/pathlib.nvim.svg?style=for-the-badge}[MLP-2.0]]
  {https://github.com/pysan3/pathlib.nvim/issues}[!{https://img.shields.io/github/issues/pysan3/pathlib.nvim.svg?style=for-the-badge}[Issues]]
  {https://github.com/pysan3/pathlib.nvim/actions/workflows/lua_ls-typecheck.yml}[!{https://img.shields.io/github/actions/workflow/status/pysan3/pathlib.nvim/lua_ls-typecheck.yml?style=for-the-badge}[Build Status]]
  {https://luarocks.org/modules/pysan3/pathlib.nvim}[!{https://img.shields.io/luarocks/v/pysan3/pathlib.nvim?logo=lua&color=purple&style=for-the-badge}[LuaRocks]]

* üêç `pathlib.nvim`
  This plugin aims to decrease the difficulties of path management across mutliple OSs in neovim.
  The plugin API is heavily inspired by Python's `pathlib.Path` with tweaks to fit neovim usage.
  It is mainly used in {https://github.com/nvim-neo-tree/neo-tree.nvim}[neo-tree.nvim]
  but it is very simple and portable to be used in any plugin.

  - {https://pysan3.github.io/pathlib.nvim/}[Documentation]
  - Module References
  -- {https://pysan3.github.io/pathlib.nvim/doc/PathlibPath.html}[`PathlibPath`]: base class with operations.
  -- {https://pysan3.github.io/pathlib.nvim/doc/PathlibPosixPath.html}[`PathlibPosixPath`]: posix system specific.
  -- {https://pysan3.github.io/pathlib.nvim/doc/PathlibWindowsPath.html}[`PathlibWindowsPath`]: posix system specific.
  - üîé Search for Keyword
  -- {https://pysan3.github.io/pathlib.nvim/search.html}[Search]
  -- {https://pysan3.github.io/pathlib.nvim/genindex.html}[Index]

* ‚ú® Benefits
** üì¶ Intuitive and Useful Methods
   @code lua
   local Path = require("pathlib")
   local dir = Path("~/Documents") -- Same as `Path.home() / "Documents"`
   local foo = dir / "foo.txt"

   print(foo:basename(), foo:stem(), foo:suffix()) -- foo.txt, foo, .txt
   print(foo:parent()) -- "/home/user/Documents"
   @end

** üìã Git Integration
   @code lua
   local git_root = Path("/path/to/git/workdir")
   -- assert(git_root:child(".git"):exists(), string.format("%s is not a git repo.", git_root))

   require("pathlib.git").fill_git_state({ file_a, file_b, ... })

   file_a.git_state.ignored  -- is git ignored
   file_a.git_state.status   -- git status (modified, added, staged, ...)
   file_a.git_state.git_root -- root directory of the repo
   @end

** ‚è±Ô∏è Sync / Async Operations
   The API is designed so it is very easy to switch between sync and async operations.
   Call them inside {https://github.com/nvim-neotest/nvim-nio}[nvim-nio task] without any change,
   and the operations are converted to be async (does not block the main thread).
   @code lua
   local foo = Path("~/Documents/foo.txt")
   local content = "File Content\n"

   -- # sync
   local sync_bytes = foo:fs_write(content)
   assert(sync_bytes == content:len(), foo.error_msg)

   -- # async
   require("nio").run(function()
     local async_bytes = foo:fs_write(content)
     assert(async_bytes == content:len(), foo.error_msg)
   end)
   @end

* üöÄ Usage Example
** Create Path Object
  @code lua
  local Path = require("pathlib")
  local cwd     = Path.cwd()
  vim.print(string.format([[cwd: %s]], cwd))

  -- Use __div to chain file tree!
  local folder  = Path(".") / "folder"
  local foo     =              folder / "foo.txt"
  assert(tostring(foo)          == "folder/foo.txt") -- $PWD/folder/foo.txt
  assert(tostring(foo:parent()) == "folder")

  -- Path object is comparable
  assert(foo                    == Path("./folder/foo.txt")) -- Path object can be created with arguments
  assert(foo                    == Path(folder, "foo.txt"))  -- Unpack any of them if you want!

  -- Create siblings (just like `./<foo>/../bar.txt`)
  local bar = foo .. "bar.txt"
  assert(tostring(bar)          == "folder/bar.txt")

  -- Calculate relativily
  assert(foo:is_relative_to(Path("folder")))
  assert(not foo:is_relative_to(Path("./different folder")))
  assert(foo:relative_to(folder) == Path("foo.txt"))
  @end

*** Path object is stored with `string[]`.
    - Very fast operations to work with parents / children / siblings.
    - No need to worry about path separator => OS Independent.
    -- `/`: Unix, `\\`: Windows

*** Nicely integrated with vim functions.
    There are wrappers around vim functions such as `fnamemodify`, `stdpath` and `getcwd`.
    @code lua
    path:modify(":p:t:r")                -- vim.fn.fnamemodify

    -- Define child directory of stdpaths
    Path.stdpath("data", "mason", "bin") -- vim.fn.stdpath("data") .. "/mason/bin"
    @end

** Create and Manipulate Files / Directories
   @code lua
   local luv = vim.loop
   local Path = require("pathlib")

   -- Create new folder
   local new_file = Path.new("./new/folder/foo.txt")
   new_file:parent():mkdir(Path.permission("rwxr-xr-x"), true) -- (permission, recursive)

   -- Create new file and write to it
   local fd = new_file:fs_open("w", Path.permission("rw-r--r--"), true)
   assert(fd ~= nil, "File creation failed. " .. new_file.error_msg)
   luv.fs_write(fd, "File Content\n")
   luv.fs_close(fd)
   -- HINT: new_file:fs_write(...) does this all at once.

   -- SHORTHAND: read file content with `io.read`
   local content = new_file:io_read()
   assert(content == "File Content\n")

   -- SHORTHAND: write to file
   new_file:io_write("File Content\n")

   new_file:copy(new_file .. "bar.txt") -- copy `foo.txt` to `bar.txt`
   new_file:symlink_to(new_file .. "baz.txt") -- create symlink of `foo.txt` named `baz.txt`
   @end

** Scan Directories
   @code lua
   -- Continue from above
   for path in new_file:parent():fs_iterdir() do
     -- loop: [Path("./new/folder/foo.txt"), Path("./new/folder/bar.txt"), Path("./new/folder/baz.txt")]
   end
   @end

** Async Execution
   This library uses {https://github.com/nvim-neotest/nvim-nio}[nvim-nio] under the hood to run async calls.
   Supported methods will turn into async calls inside a `nio.run` environment
   and has the *EXACT SAME INTERFACE*.

   @code lua
   local nio = require("nio")
   local path = Path("foo.txt")
   nio.run(function() -- async run (does not block the main thread)
     vim.print(path:fs_stat())       -- coroutine (async)
     path:fs_write("File Content\n") -- coroutine (async)
     vim.print(path:fs_read())       -- coroutine (async)
     vim.print("async done")         -- prints last
   end)

   vim.print("sync here") -- prints first (maybe not if above functions end very fast)
   @end

   When execution fails, function will return `nil` and the error message is
   captured into `self.error_msg`.
   This property holds the error message of the latest async function call.

   @code lua
   nio.run(function ()
     local path = Path("./does/not/exist.txt")
     local fd = path:fs_open("r")
     assert(fd, "ERROR: " .. path.error_msg)
     -- fd will be nil when `:fs_open` fails. Check `self.error_msg` for the error message.
   end)
   @end

* TODO
  - ( ) API documentation.
  - (-) Git operation integration.
  - ( ) Windows implementation, test environment.

* Contributions
  I am not thinking of merging any PRs yet but feel free to give me your opinions with an issue.

* Other Projects
  - Python `pathlib`
  -- {https://docs.python.org/3/library/pathlib.html}
